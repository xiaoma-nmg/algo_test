散列表



散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。

通过散裂函数把 元素的键映射为下标，然后数据的值存储在对应下标的位置。查询时，依旧把键映射为下标去取数据

散列表的两个核心问题：1。散列函数设计 2。散列冲突解决

散列函数：可以定义为 hash(key)
    如何构造散列函数？要满足下面3点基本要求
    1。散列函数计算得到的散裂值是一个非负整数
    2。如果key1==key2,那么 hash(key1) == hash(key2)，保证唯一性
    3。如果key1!=key2,那么 hash(key1) != hash(key2), 避免散列冲突
    
散列冲突： 再好的散列函数也无法避免散列冲突，常用的散列冲突的解决方法有：
    1。开放寻址法： 如果散列冲突，重新探测一个空闲的位置，将其插入
        重新探测位置的方法：
            1。线性探测： 如果散列之后的位置已经被占用，就依次往后查找，直到找到第一个空闲位置 （最坏情况可能退化成O(n)）
            2。二次探测： 跟线性探测类似，线性探测每次的步长是1，所以探测的序列为 hash(key)+1,hash(key)+2...而二次探测
                        的步长就是原来步长的二次方，所以探测的序列为 hash(key)+1^2, hash(key)+2^2....
            3。双重散列： 先使用一次散列 hash(key),如果该位置被占用，再用第二个散列函数，依次类推，直到找到空闲位置去存储
        不管用哪种探测方法，当散列表中空闲位置不多的时候，总是容易发生散列冲突，为了尽可能的保证散列操作的效率，一般情况下要保证散列表中
        空闲的位置在一个比例范围。这个比例称作 装载因子
            装载因子=已占用位置的个数/散列表的大小
    2。链表法：将每个存储位置看作是一个"桶"， 每个桶对应一条链表，所有散列结果相同的值，存储在这条链表中。
        
    